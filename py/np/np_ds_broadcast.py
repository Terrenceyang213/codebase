#%% tags:numpy;np;brodcast;numpy运算广播
# 广播的规则:

#     让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。
#     输出数组的形状是输入数组形状的各个维度上的最大值。
#     如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。
#     当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。

# 简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：

#     数组拥有相同形状。
#     当前维度的值相等。
#     当前维度的值有一个是 1。

# 若条件不满足，抛出 "ValueError: frames are not aligned" 异常。
import numpy as np


#%%
a = np.array([[1,2,3]])
b = np.array([[1,2,3,4]])
a*b 
# 广播错误
# ValueError: operands could not be broadcast together with shapes (1,3) (1,4) 

#%% tag:priciple of brodcast;广播原理
import numpy as np
X = np.random.random((32, 10)) # 0轴不同
y = np.random.random((10,))
# array([0.6671181 , 0.83681924, 0.67615045])

y = np.expand_dims(y, axis=0)
print(y.shape)
print(y)
# (1, 3)
# [[0.51890444 0.14930862 0.05850427]]

Y = np.concatenate([y] * 10, axis=0)
Y
# array([[0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427],
#        [0.51890444, 0.14930862, 0.05850427]])
