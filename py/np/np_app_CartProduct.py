#%%
import numpy as np


#%% meshgrid;生成高维坐标数组；
x = np.array([-1, 0, 1])
y = np.array([-2, 0, 2])
X, Y = np.meshgrid(x, y)

X
# array([[-1,  0,  1],
#        [-1,  0,  1],
#        [-1,  0,  1]])
Y
# array([[-2, -2, -2],
#        [ 0,  0,  0],
#        [ 2,  2,  2]])

Z = (X + Y) ** 2
# array([[9, 4, 1],
#        [1, 0, 1],
#        [1, 4, 9]], dtype=int32)

# %%
# 三个行向量
a = np.array([1,2,3])
b = np.array([1,2,3])
c = np.array([4,5,6])

# 一个根据标量计算的函数
def f(a, b, c):
    return a+b*c

f(a,b,c)
# array([ 5, 12, 21])

# %% 多元向量笛卡尔积
# 这种比较方便画图
A,B,C = [x.reshape(1,27) for x in np.meshgrid(a,b,c)]
# array([[1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3]]),
# array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3]]),
# array([[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]])
f(A,B,C)
# array([[5,  6,  7,  6,  7,  8,  7,  8,  9,  9, 11, 13, 10, 12, 14, 11, 13, 15, 13, 16, 19, 14, 17, 20, 15, 18, 21]])

# %% 向量可组成向量组
X = np.concatenate((A,B,C), axis=0)
# array([[1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2,
#         2, 2, 3, 3, 3],
#        [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
#         3, 3, 3, 3, 3],
#        [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4,
#         5, 6, 4, 5, 6]])
f(*X)
# array([[5,  6,  7,  6,  7,  8,  7,  8,  9,  9, 11, 13, 10, 12, 14, 11, 13, 15, 13, 16, 19, 14, 17, 20, 15, 18, 21]])

# %% 不作reshape
A,B,C = np.meshgrid(a,b,c)
# A
# array([[[1, 1, 1],
#         [2, 2, 2],
#         [3, 3, 3]],

#        [[1, 1, 1],
#         [2, 2, 2],
#         [3, 3, 3]],

#        [[1, 1, 1],
#         [2, 2, 2],
#         [3, 3, 3]]])

# B
# array([[[1, 1, 1],
#         [1, 1, 1],
#         [1, 1, 1]],

#        [[2, 2, 2],
#         [2, 2, 2],
#         [2, 2, 2]],

#        [[3, 3, 3],
#         [3, 3, 3],
#         [3, 3, 3]]])

# C
# array([[[4, 5, 6],
#         [4, 5, 6],
#         [4, 5, 6]],

#        [[4, 5, 6],
#         [4, 5, 6],
#         [4, 5, 6]],

#        [[4, 5, 6],
#         [4, 5, 6],
#         [4, 5, 6]]])        

f(A,B,C)
# array([[[ 5,  6,  7],
#         [ 6,  7,  8],
#         [ 7,  8,  9]],

#        [[ 9, 11, 13],
#         [10, 12, 14],
#         [11, 13, 15]],

#        [[13, 16, 19],
#         [14, 17, 20],
#         [15, 18, 21]]])

# %% 笛卡尔集的计算时间
%timeit A,B,C = [x.reshape(1,27) for x in np.meshgrid(a,b,c)]
# 28 µs ± 534 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

