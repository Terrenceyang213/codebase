#%%
import numpy as np
def aid(x):
    # This function returns the memory
    # block address of an array.
    return x.__array_interface__['data'][0]

#%% order
'''
order 关键字给出保存数据的顺序
order = 'C' 行主序：按顺序逐行存储
order = 'F' 列主序：按顺序逐列存储
'''
sc = np.array([1,2,3], order='C')
sf = np.array([4,5,6], order='F')


# %% strides
'''
Strides are integer numbers describing the byte step in the contiguous block of memory for each dimension.
strides是np多维数组的一个元组，元组个数是等于维数。
其含义在于，内存中，每个维度的偏移量。
比如在行主列中，一个(3,2)形状的矩阵，每个int元素4字节，总共4*6=24字节
strides=(行偏移量，列偏移量)=(4*3,4)=(12,4)
'''
sc = np.zeros((10,10), order='C')
# |8 -> 8 -> 8 -> 8 -> ...|
# |8 -> 8 -> 8|
sc.strides
# (80, 8)

sf = np.zeros((10,10), order='F')
# |8| |8| |8| ...    
# |8| |8| |8|
# ...
sf.strides
# (8, 80)

# 地址解析
aid(sc[2,3]) - aid(sc[0,0])



# %% 向量复制；向量扩展；提速优化；矩阵乘法
# np.lib.stride_tricks.as_strided
# strides的trick
'''
We will create a new array, b, pointing to the same memory block as a, 
but with a different shape and different strides. 
This new array will look like a vertically-tiled version of a. 
We use a special function in NumPy to change the strides of an array:

NumPy believes that this array contains one million different elements, 
whereas the data buffer actually contains the same 1000 elements as a.
'''
n = 1000
a = np.arange(n)
b = np.lib.stride_tricks.as_strided(a, (n, n), (0, 4)) #这个函数一定要弄对字节数，不然会出错。

b.size, b.shape, b.nbytes
# (1000000, (1000, 1000), 4000000)

# 这个trick可以提高向量扩展出来的矩阵运算速度
# 这个操作基本不耗时间，因为不涉及内存分配
%timeit b * b.T
# 100 loops, best of 3: 2.28 ms per loop
%timeit d = np.lib.stride_tricks.as_strided(a, (n, n), (0, 8)); d * d.T;
# 100 loops, best of 3: 2.16 ms per loop

%timeit np.tile(a, (n, 1)) * np.tile(a[:, np.newaxis], (1, n))
# 100 loops, best of 3: 6.01 ms per loop

c = np.tile(a,(n,1))
%timeit c *c.T
# 100 loops, best of 3: 3.06 ms per loop

%timeit c = np.tile(a,(n,1)); c *c.T;
# 100 loops, best of 3: 3.59 ms per loop


a[0]=1000
b
# array([[1000,    1,    2, ...,  997,  998,  999],
#        [1000,    1,    2, ...,  997,  998,  999],
#        [1000,    1,    2, ...,  997,  998,  999],
#        ...,
#        [1000,    1,    2, ...,  997,  998,  999],
#        [1000,    1,    2, ...,  997,  998,  999],
#        [1000,    1,    2, ...,  997,  998,  999]])



#%%  np.lib.stride_tricks.as_strided(x, shape=None, strides=None, subok=False, writeable=True)
# Parameters

    # x: ndarray
    #     Array to create a new.
    
    # shape:sequence of int, optional
    #     The shape of the new array. Defaults to x.shape.

    # strides:sequence of int, optional
    #     The strides of the new array. Defaults to x.strides.

    # subok:bool, optional
    #     New in version 1.10.
    #     If True, subclasses are preserved.
    
    # writeable:bool, optional
    #     New in version 1.12.
    #     If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).

# for a array x, shape决定最终的矩阵样式，而stride决定从第二行开始的数据如何取数。
# 但是不论如何取数，数值不能超过其本来的内存模块
x = np.linspace(1,6,6)
# array([1., 2., 3., 4., 5., 6.],dtype('float64'))
x.strides
# (8,)

# 构造一个2*6的矩阵
np.lib.stride_tricks.as_strided(x, (2,6), (8,8))
# array([[1.0000e+000, 2.0000e+000, 3.0000e+000, 4.0000e+000, 5.0000e+000, 6.0000e+000],
#        [2.0000e+000, 3.0000e+000, 4.0000e+000, 5.0000e+000, 6.0000e+000, 7.8665e-320]])

np.lib.stride_tricks.as_strided(x, (2,6), (8*2,8))
# array([[ 1.00000000e+000,  2.00000000e+000,  3.00000000e+000, 4.00000000e+000,  5.00000000e+000,  6.00000000e+000],
#        [ 3.00000000e+000,  4.00000000e+000,  5.00000000e+000, 6.00000000e+000,  3.33774999e-307, -7.02506094e-251]])

# 该函数根据第三个参数对内存进行index，从而产生其他维度的数据
# shape 和 stride必须完美契合，才能构造出新的矩阵。

#%% 利用as_strides对一维时间序列进行分组
s = np.linspace(1,96,96) # 1...96
# 6个元素一组，分16组
np.lib.stride_tricks.as_strided(s, (16,6), (s.itemsize*6, s.itemsize))
# array([[ 1.,  2.,  3.,  4.,  5.,  6.],
#        [ 7.,  8.,  9., 10., 11., 12.],
#        [13., 14., 15., 16., 17., 18.],
#        [19., 20., 21., 22., 23., 24.],
#        [25., 26., 27., 28., 29., 30.],
#        [31., 32., 33., 34., 35., 36.],
#        [37., 38., 39., 40., 41., 42.],
#        [43., 44., 45., 46., 47., 48.],
#        [49., 50., 51., 52., 53., 54.],
#        [55., 56., 57., 58., 59., 60.],
#        [61., 62., 63., 64., 65., 66.],
#        [67., 68., 69., 70., 71., 72.],
#        [73., 74., 75., 76., 77., 78.],
#        [79., 80., 81., 82., 83., 84.],
#        [85., 86., 87., 88., 89., 90.],
#        [91., 92., 93., 94., 95., 96.]])

# 16个一组，分6组
np.lib.stride_tricks.as_strided(s, (6,16), (s.itemsize*16, s.itemsize))
# array([[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15., 16.],
#        [17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31., 32.],
#        [33., 34., 35., 36., 37., 38., 39., 40., 41., 42., 43., 44., 45., 46., 47., 48.],
#        [49., 50., 51., 52., 53., 54., 55., 56., 57., 58., 59., 60., 61., 62., 63., 64.],
#        [65., 66., 67., 68., 69., 70., 71., 72., 73., 74., 75., 76., 77., 78., 79., 80.],
#        [81., 82., 83., 84., 85., 86., 87., 88., 89., 90., 91., 92., 93., 94., 95., 96.]])

np.lib.stride_tricks.as_strided(s, (6,16), (s.itemsize, s.itemsize*6))
# 分组成为列向量
# array([[ 1.,  7., 13., 19., 25., 31., 37., 43., 49., 55., 61., 67., 73., 79., 85., 91.],
#        [ 2.,  8., 14., 20., 26., 32., 38., 44., 50., 56., 62., 68., 74., 80., 86., 92.],
#        [ 3.,  9., 15., 21., 27., 33., 39., 45., 51., 57., 63., 69., 75., 81., 87., 93.],
#        [ 4., 10., 16., 22., 28., 34., 40., 46., 52., 58., 64., 70., 76., 82., 88., 94.],
#        [ 5., 11., 17., 23., 29., 35., 41., 47., 53., 59., 65., 71., 77., 83., 89., 95.],
#        [ 6., 12., 18., 24., 30., 36., 42., 48., 54., 60., 66., 72., 78., 84., 90., 96.]])
#%% 利用as_strides该分组求解R/S
#分组
a = np.lib.stride_tricks.as_strided(s, (6,16), (s.itemsize*16, s.itemsize))
# array([[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15., 16.],
#        [17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31., 32.],
#        [33., 34., 35., 36., 37., 38., 39., 40., 41., 42., 43., 44., 45., 46., 47., 48.],
#        [49., 50., 51., 52., 53., 54., 55., 56., 57., 58., 59., 60., 61., 62., 63., 64.],
#        [65., 66., 67., 68., 69., 70., 71., 72., 73., 74., 75., 76., 77., 78., 79., 80.],
#        [81., 82., 83., 84., 85., 86., 87., 88., 89., 90., 91., 92., 93., 94., 95., 96.]])


# 组内均值--------------------------------------------------------
am = np.mean(a,axis=1)
# array([ 8.5, 24.5, 40.5, 56.5, 72.5, 88.5])


# 离差，这两个矩阵是无法直接广播的，必须从右边开始兼容----------------
# a:    6*16 -> 6*16
# am:   6    -> 6*1   
am[:,np.newaxis]
# array([[ 8.5],
#        [24.5],
#        [40.5],
#        [56.5],
#        [72.5],
#        [88.5]])
# shape:(6, 1)
adev = a - am[:,np.newaxis]
# array([[-7.5, -6.5, -5.5, -4.5, -3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,
#          3.5,  4.5,  5.5,  6.5,  7.5],
#        [-7.5, -6.5, -5.5, -4.5, -3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,
#          3.5,  4.5,  5.5,  6.5,  7.5],
#        [-7.5, -6.5, -5.5, -4.5, -3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,
#          3.5,  4.5,  5.5,  6.5,  7.5],
#        [-7.5, -6.5, -5.5, -4.5, -3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,
#          3.5,  4.5,  5.5,  6.5,  7.5],
#        [-7.5, -6.5, -5.5, -4.5, -3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,
#          3.5,  4.5,  5.5,  6.5,  7.5],
#        [-7.5, -6.5, -5.5, -4.5, -3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,
#          3.5,  4.5,  5.5,  6.5,  7.5]])

#累积离差和-------------------------------------------------------------------
adevsum = np.cumsum(adev,axis=1)
# array([[ -7.5, -14. , -19.5, -24. , -27.5, -30. , -31.5, -32. , -31.5,
#         -30. , -27.5, -24. , -19.5, -14. ,  -7.5,   0. ],
#        [ -7.5, -14. , -19.5, -24. , -27.5, -30. , -31.5, -32. , -31.5,
#         -30. , -27.5, -24. , -19.5, -14. ,  -7.5,   0. ],
#        [ -7.5, -14. , -19.5, -24. , -27.5, -30. , -31.5, -32. , -31.5,
#         -30. , -27.5, -24. , -19.5, -14. ,  -7.5,   0. ],
#        [ -7.5, -14. , -19.5, -24. , -27.5, -30. , -31.5, -32. , -31.5,
#         -30. , -27.5, -24. , -19.5, -14. ,  -7.5,   0. ],
#        [ -7.5, -14. , -19.5, -24. , -27.5, -30. , -31.5, -32. , -31.5,
#         -30. , -27.5, -24. , -19.5, -14. ,  -7.5,   0. ],
#        [ -7.5, -14. , -19.5, -24. , -27.5, -30. , -31.5, -32. , -31.5,
#         -30. , -27.5, -24. , -19.5, -14. ,  -7.5,   0. ]])

#组内极差--------------------------------------------------------------------
amaxdev = np.max(adevsum,axis=1)
# array([0., 0., 0., 0., 0., 0.]) shape:(6,)

amindev = np.min(adevsum,axis=1)
# array([-32., -32., -32., -32., -32., -32.]) shape:(6,)

# 组内极差
adevdiff = amaxdev - amindev
# array([32., 32., 32., 32., 32., 32.])

# 组内标准差-----------------------------------------------------------------
astd = np.std(a,axis=1)
# array([4.60977223, 4.60977223, 4.60977223, 4.60977223, 4.60977223, 4.60977223])

# 分组R/S   -----------------------------------------------------------------
arspergroup = adevdiff/astd
# array([6.94177465, 6.94177465, 6.94177465, 6.94177465, 6.94177465, 6.94177465])

# 在（6,16)这一划分中，r/s均值
arsmean = np.mean(arspergroup,axis=1)
# 6.941774650196997